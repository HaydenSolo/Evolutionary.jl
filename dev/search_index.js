var documenterSearchIndex = {"docs":
[{"location":"selection/#Selection-1","page":"Selection","title":"Selection","text":"","category":"section"},{"location":"selection/#","page":"Selection","title":"Selection","text":"Selection is a genetic operator used in EAs for selecting potentially useful solutions from a population for later breeding. The EAs are stochastic search methods using the concepts of Mendelian genetics and Darwinian evolution. According to Darwin's evolution theory the best ones should survive and create new offspring. There are many methods how to select the best individuals, for example roulette wheel selection, Boltzman selection, tournament selection, rank selection, steady state selection and some others.","category":"page"},{"location":"selection/#Selection-Interface-1","page":"Selection","title":"Selection Interface","text":"","category":"section"},{"location":"selection/#","page":"Selection","title":"Selection","text":"All selection algorithms have following call interface selection(fintess, N) where fintess is the vector of population fitness values, of size M, and N is the number of selected individuals. The selection function returns a vector of integer indexes of selected individuals, of size N with indexes in range 1M.","category":"page"},{"location":"selection/#","page":"Selection","title":"Selection","text":"Note: Some of the selection algorithms implemented as function closures, in order to provide additional parameters to the specified above selection interface.","category":"page"},{"location":"selection/#Operations-1","page":"Selection","title":"Operations","text":"","category":"section"},{"location":"selection/#","page":"Selection","title":"Selection","text":"List of the selection operations:","category":"page"},{"location":"selection/#","page":"Selection","title":"Selection","text":"ranklinear\nuniformranking\nroulette\nrouletteinv\nsus\nsusinv\ntruncation\ntournament","category":"page"},{"location":"selection/#Evolutionary.ranklinear","page":"Selection","title":"Evolutionary.ranklinear","text":"ranklinear(sp::Real)\n\nReturns a rank-based fitness selection function, see Selection Interface, with the selective pressure value sp.\n\nIn rank-based fitness selection, the population is sorted according to the objective values. The fitness assigned to each individual depends only on its position in the individuals rank and not on the actual objective value [1].\n\nConsider M the number of individuals in the population, P the position of an individual in this population (least fit individual has P = 1, the fittest individual P = M) and SP the selective pressure. The fitness value for an individual is calculated as:\n\nFitness(P) = 2 - SP + frac2(SP - 1)(P - 1)(M - 1)\n\nLinear ranking allows values of selective pressure in [1.0, 2.0].\n\n\n\n\n\n","category":"function"},{"location":"selection/#Evolutionary.uniformranking","page":"Selection","title":"Evolutionary.uniformranking","text":"uniformranking(μ)\n\nReturns a (μ, λ)-uniform ranking selection function, see Selection Interface with the best individuals parameter μ.\n\nIn uniform ranking, the best mu individuals are assigned a selection probability of 1mu while the rest them are discarded [2].\n\n\n\n\n\n","category":"function"},{"location":"selection/#Evolutionary.roulette","page":"Selection","title":"Evolutionary.roulette","text":"roulette(fitness)\n\nRoulette wheel (fitness proportionate, FPS) selection from fitness collection.\n\nIn roulette selection, the fitness level is used to associate a probability of selection with each individual. If f_i is the fitness of individual i in the population, its probability of being selected is p_i = fracf_iSigma_j=1^M f_j, where M is the number of individuals in the population.\n\nNote: Best used in maximization context.\n\n\n\n\n\n","category":"function"},{"location":"selection/#Evolutionary.rouletteinv","page":"Selection","title":"Evolutionary.rouletteinv","text":"rouletteinv(fitness)\n\nFitness proportionate selection (FPS) or roulette wheel for inverse fitness values. Best used in minimization context.\n\n\n\n\n\n","category":"function"},{"location":"selection/#Evolutionary.sus","page":"Selection","title":"Evolutionary.sus","text":"sus(fitness, N)\n\nStochastic universal sampling (SUS) provides zero bias and minimum spread [3]. SUS is a development of fitness proportionate selection (FPS). Using a comb-like ruler, SUS starts from a small random number, and chooses the next candidates from the rest of population remaining, not allowing the fittest members to saturate the candidate space. The individuals are mapped to contiguous segments of a line, such that each individual's segment is equal in size to its fitness exactly as in roulette-wheel selection. Here equally spaced pointers are placed over the line as many as there are individuals to be selected.\n\nConsider N the number of individuals to be selected, then the distance between the pointers are 1N and the position of the first pointer is given by a randomly generated number in the range 0 1N.\n\nNote: Best used in maximization context.\n\n\n\n\n\n","category":"function"},{"location":"selection/#Evolutionary.susinv","page":"Selection","title":"Evolutionary.susinv","text":"susinv(fitness)\n\nInverse fitness SUS. Best used in minimization context.\n\n\n\n\n\n","category":"function"},{"location":"selection/#Evolutionary.truncation","page":"Selection","title":"Evolutionary.truncation","text":"truncation(fitness, N)\n\nTruncation selection returns first N of best fitness inividuals\n\n\n\n\n\n","category":"function"},{"location":"selection/#Evolutionary.tournament","page":"Selection","title":"Evolutionary.tournament","text":"Tournament selection\n\n\n\n\n\n","category":"function"},{"location":"selection/#References-1","page":"Selection","title":"References","text":"","category":"section"},{"location":"selection/#","page":"Selection","title":"Selection","text":"[1]: Baker J.E., Adaptive selection methods for genetic algorithms, In Proceedings of International Conference on Genetic Algorithms and Their Applications, pp. 100-111, 1985.","category":"page"},{"location":"selection/#","page":"Selection","title":"Selection","text":"[2]: Schwefel H.P., Evolution and Optimum Seeking, Wiley, New York, 1995.","category":"page"},{"location":"selection/#","page":"Selection","title":"Selection","text":"[3]: Baker, J. E., Reducing Bias and Inefficiency in the Selection Algorithm. In [ICGA2], pp. 14-21, 1987.","category":"page"},{"location":"dev/#Development-1","page":"Development","title":"Development","text":"","category":"section"},{"location":"dev/#","page":"Development","title":"Development","text":"CurrentModule = Evolutionary","category":"page"},{"location":"dev/#","page":"Development","title":"Development","text":"If you are contributing a new algorithm to this package, you need to know an internal API which allows to add a new algorithm without considerable changes to overall structure of the package.","category":"page"},{"location":"dev/#Adding-an-algorithm-1","page":"Development","title":"Adding an algorithm","text":"","category":"section"},{"location":"dev/#","page":"Development","title":"Development","text":"If you're contributing a new algorithm, you shouldn't need to touch any of the code in src/api/optimize.jl. You should rather add a file named (solver is the name of the solver) algo.jl in src, and make sure that you define an optimizer parameters and state types, initial_population that initializes a population of individual objects, a state type that holds all variables that are (re)used throughout the iterative procedure, an initial_state that initializes such a state, and an update_state! method that does the actual work.","category":"page"},{"location":"dev/#Algorithm-1","page":"Development","title":"Algorithm","text":"","category":"section"},{"location":"dev/#","page":"Development","title":"Development","text":"Every optimization algorithm have to implement an algorithm parameters type derived from  AbstractOptimizer type,  e.g. struct Algo <: AbstractOptimizer end, with appropriate fields, a default constructor with a keyword for each field.","category":"page"},{"location":"dev/#","page":"Development","title":"Development","text":"Function initial_state returns an initial state for the algorithm, see State section. Function update_state! returns a Bool value. If the state update is successfully completed then the function returns false, otherwise true.","category":"page"},{"location":"dev/#","page":"Development","title":"Development","text":"AbstractOptimizer\ninitial_state","category":"page"},{"location":"dev/#Evolutionary.AbstractOptimizer","page":"Development","title":"Evolutionary.AbstractOptimizer","text":"Abstract evolutionary optimizer algorithm\n\n\n\n\n\n","category":"type"},{"location":"dev/#Evolutionary.initial_state","page":"Development","title":"Evolutionary.initial_state","text":"Initialization of ES algorithm state\n\n\n\n\n\nInitialization of CMA-ES algorithm state\n\n\n\n\n\nInitialization of GA algorithm state\n\n\n\n\n\n","category":"function"},{"location":"dev/#State-1","page":"Development","title":"State","text":"","category":"section"},{"location":"dev/#","page":"Development","title":"Development","text":"Every optimization algorithm have to implement a state type derived from AbstractOptimizerState type, e.g. struct AlgoState <: AbstractOptimizerState end. All derived types should implement value and minimizer functions","category":"page"},{"location":"dev/#","page":"Development","title":"Development","text":"AbstractOptimizerState\nvalue(::AbstractOptimizerState)\nminimizer(::AbstractOptimizerState)\nterminate(::AbstractOptimizerState)","category":"page"},{"location":"dev/#Evolutionary.AbstractOptimizerState","page":"Development","title":"Evolutionary.AbstractOptimizerState","text":"Abstract type for defining an optimizer state\n\nEvery algorithm have to implement a state type derived from this abstract type.\n\n\n\n\n\n","category":"type"},{"location":"dev/#NLSolversBase.value-Tuple{Evolutionary.AbstractOptimizerState}","page":"Development","title":"NLSolversBase.value","text":"value(state)\n\nReturns a minimum value of the current state.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Evolutionary.minimizer-Tuple{Evolutionary.AbstractOptimizerState}","page":"Development","title":"Evolutionary.minimizer","text":"value(state)\n\nReturns a minimizer object in the current state.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Evolutionary.terminate-Tuple{Evolutionary.AbstractOptimizerState}","page":"Development","title":"Evolutionary.terminate","text":"terminate(state)\n\nReturns true if the state requires early termination.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Population-1","page":"Development","title":"Population","text":"","category":"section"},{"location":"dev/#","page":"Development","title":"Development","text":"The evolutionary algorithms require a collection of individuals, population, which the algorithm constantly modifies. The population collection type must be derived from the AbstractVector type. Function initial_population is used for implementing a strategy of population collection initialization.","category":"page"},{"location":"dev/#","page":"Development","title":"Development","text":"The initial_population must accept two parameters:","category":"page"},{"location":"dev/#","page":"Development","title":"Development","text":"method, an algorithm object derived from AbstractOptimizer type\nindividual, a description of an individual template used to create the population","category":"page"},{"location":"dev/#","page":"Development","title":"Development","text":"Following population initialization strategies are available:","category":"page"},{"location":"dev/#","page":"Development","title":"Development","text":"initial_population(::M, ::I) where {M<:AbstractOptimizer, I<:AbstractVector}\ninitial_population(::M, ::Function) where {M<:AbstractOptimizer}\ninitial_population(::M, ::I) where {M<:AbstractOptimizer, I<:AbstractMatrix}","category":"page"},{"location":"dev/#Evolutionary.initial_population-Union{Tuple{I}, Tuple{M}, Tuple{M,I}} where I<:(AbstractArray{T,1} where T) where M<:Evolutionary.AbstractOptimizer","page":"Development","title":"Evolutionary.initial_population","text":"initial_population(method, individual::AbstractVector)\n\nInitialize population by replicating the inividual vector.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Evolutionary.initial_population-Union{Tuple{M}, Tuple{M,Function}} where M<:Evolutionary.AbstractOptimizer","page":"Development","title":"Evolutionary.initial_population","text":"initial_population(method, individual::Function)\n\nInitialize population from the inividual function which returns an individual object.\n\n\n\n\n\n","category":"method"},{"location":"dev/#Evolutionary.initial_population-Union{Tuple{I}, Tuple{M}, Tuple{M,I}} where I<:(AbstractArray{T,2} where T) where M<:Evolutionary.AbstractOptimizer","page":"Development","title":"Evolutionary.initial_population","text":"initial_population(method, individuals::AbstractMatrix)\n\nInitialize population from the inividuals matrix where each individual is a column.\n\n\n\n\n\n","category":"method"},{"location":"cmaes/#CMA-ES-1","page":"CMA-ES","title":"CMA-ES","text":"","category":"section"},{"location":"cmaes/#","page":"CMA-ES","title":"CMA-ES","text":"CMAES","category":"page"},{"location":"cmaes/#Evolutionary.CMAES","page":"CMA-ES","title":"Evolutionary.CMAES","text":"Covariance Matrix Adaptation Evolution Strategy Implementation: (μ/μ_I,λ)-CMA-ES\n\nThe constructor takes following keyword arguments:\n\nμ is the number of parents\nλ is the number of offspring\nτ is a time constant for a direction vector s\nτ_c is a time constant for a covariance matrix C\nτ_σ is a time constant for a global step size σ\n\n\n\n\n\n","category":"type"},{"location":"cmaes/#Description-1","page":"CMA-ES","title":"Description","text":"","category":"section"},{"location":"cmaes/#","page":"CMA-ES","title":"CMA-ES","text":"The Covariance Matrix Adaptation Evolution Strategy (CMA-ES) is a stochastic derivative-free numerical optimization algorithm for difficult (non-convex, ill-conditioned, multi-modal, rugged, noisy) optimization problems in continuous search spaces [1].","category":"page"},{"location":"cmaes/#","page":"CMA-ES","title":"CMA-ES","text":"The current CMA-ES algorithm implementation based on a simplified outline[2].","category":"page"},{"location":"cmaes/#References-1","page":"CMA-ES","title":"References","text":"","category":"section"},{"location":"cmaes/#","page":"CMA-ES","title":"CMA-ES","text":"[1]: Hansen, N. (2016), \"The CMA Evolution Strategy: A Tutorial\", arXiv:1604.00772","category":"page"},{"location":"cmaes/#","page":"CMA-ES","title":"CMA-ES","text":"[2]: http://www.scholarpedia.org/article/Evolution_strategies","category":"page"},{"location":"es/#Evolution-Strategies-1","page":"Evolution Strategy","title":"Evolution Strategies","text":"","category":"section"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"ES","category":"page"},{"location":"es/#Evolutionary.ES","page":"Evolution Strategy","title":"Evolutionary.ES","text":"Implementation of Evolution Strategy: (μ/ρ(+/,)λ)-ES\n\nThe constructor takes following keyword arguments:\n\ninitStrategy: an initial strategy description, (default: empty)\nrecombination: ES recombination function for population (default: first), see Crossover\nsrecombination: ES recombination function for strategies (default: first), see Crossover\nmutation: Mutation function for population (default: first)\nsmutation: Mutation function for strategies (default: identity)\nμ: the number of parents\nρ: the mixing number, ρ ≤ μ, (i.e., the number of parents involved in the procreation of an offspring)\nλ: the number of offspring\nselection: the selection strategy :plus or :comma (default: :plus)\n\n\n\n\n\n","category":"type"},{"location":"es/#Description-1","page":"Evolution Strategy","title":"Description","text":"","category":"section"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"The Evolution Strategy  is  is an optimization technique based on ideas of evolution.","category":"page"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"Evolution strategies use natural problem-dependent representations, and primarily Mutation and Selection, as search operators.","category":"page"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"The canonical versions of the ES are denoted by (sigmarholambda)-ES and (μ/ρ+λ)-ES, respectively. Here mu denotes the number of parents, rho leq mu the mixing number (i.e., the number of parents involved in the procreation of an offspring), and lambda the number of offspring. The parents are deterministically selected (i.e., deterministic survivor selection) from the (multi-)set of either the offspring, referred to as comma-selection (mu  lambda must hold), or both the parents and offspring, referred to as plus-selection [1].","category":"page"},{"location":"es/#Strategies-1","page":"Evolution Strategy","title":"Strategies","text":"","category":"section"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"The evolution strategy algorithm provides, for every the optimized object parameter vector x, a set of strategy parameters s. The strategy is used to create an offspring x^prime is generated from the population individual x on every iteration of the algorithm by applying a mutation operation:","category":"page"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"x^prime = mutation(x s)","category":"page"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"A strategy s usually has a parameter, e.g. sigma, that controls the strength of the object parameter mutation. For example, if the mutation operation is gaussian then the sigma is simply the standard deviation of the normally distributed random component.","category":"page"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"List of ES strategies:","category":"page"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"AbstractStrategy\nNoStrategy\nIsotropicStrategy\nIsotropicStrategy(::Integer)\nAnisotropicStrategy\nAnisotropicStrategy(::Integer)","category":"page"},{"location":"es/#Evolutionary.AbstractStrategy","page":"Evolution Strategy","title":"Evolutionary.AbstractStrategy","text":"Abstract evolution strategy\n\nAll evolution strategies must be derived from this type.\n\n\n\n\n\n","category":"type"},{"location":"es/#Evolutionary.NoStrategy","page":"Evolution Strategy","title":"Evolutionary.NoStrategy","text":"Empty evolution strategy\n\n\n\n\n\n","category":"type"},{"location":"es/#Evolutionary.IsotropicStrategy","page":"Evolution Strategy","title":"Evolutionary.IsotropicStrategy","text":"Isotropic evolution strategy\n\nThis strategy has one mutation parameter for all object parameter components.\n\n\n\n\n\n","category":"type"},{"location":"es/#Evolutionary.IsotropicStrategy-Tuple{Integer}","page":"Evolution Strategy","title":"Evolutionary.IsotropicStrategy","text":"IsotropicStrategy(N)\n\nReturns an isotropic strategy object, which has an one mutation parameter for all object parameter components, with sigma = 10, tau_0 = sqrt2N^-1, tau = sqrt2sqrtN^-1\n\n\n\n\n\n","category":"method"},{"location":"es/#Evolutionary.AnisotropicStrategy","page":"Evolution Strategy","title":"Evolutionary.AnisotropicStrategy","text":"Anisotropic evolution strategy\n\nThis strategy has a mutation parameter for each object parameter component.\n\n\n\n\n\n","category":"type"},{"location":"es/#Evolutionary.AnisotropicStrategy-Tuple{Integer}","page":"Evolution Strategy","title":"Evolutionary.AnisotropicStrategy","text":"AnisotropicStrategy(N)\n\nReturns an anisotropic strategy object, which has an one mutation parameter for each object parameter component, with sigma = 1 ldots 1^N, tau_0 = sqrt2N^-1, tau = sqrt2sqrtN^-1\n\n\n\n\n\n","category":"method"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"See Mutation section for strategy mutation operations.","category":"page"},{"location":"es/#References-1","page":"Evolution Strategy","title":"References","text":"","category":"section"},{"location":"es/#","page":"Evolution Strategy","title":"Evolution Strategy","text":"[1]: http://www.scholarpedia.org/article/Evolution_strategies","category":"page"},{"location":"mutation/#Mutation-1","page":"Mutation","title":"Mutation","text":"","category":"section"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"In genetic algorithms and evolutionary computation, mutation is a genetic operator used to maintain a diversity from one generation of a population to the next. It is analogous to biological mutation. Mutation alters one or more gene values in a chromosome from its initial state. The purpose of mutation is to introduce diversity into the sampled population.","category":"page"},{"location":"mutation/#Mutation-Interface-1","page":"Mutation","title":"Mutation Interface","text":"","category":"section"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"All mutation operations have following call interface mutation(individual) where individual is the member of population. The mutation function returns an in-place mutated individual.","category":"page"},{"location":"mutation/#Evolutionary-Strategy-1","page":"Mutation","title":"Evolutionary Strategy","text":"","category":"section"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"See Strategies section for detailed description of ES strategies.","category":"page"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"List of ES mutation operations:","category":"page"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"gaussian(::AbstractVector, ::IsotropicStrategy)\ngaussian(::AbstractVector, ::AnisotropicStrategy)\ncauchy(::AbstractVector, ::IsotropicStrategy)","category":"page"},{"location":"mutation/#Evolutionary.gaussian-Tuple{AbstractArray{T,1} where T,IsotropicStrategy}","page":"Mutation","title":"Evolutionary.gaussian","text":"gaussian(x, s::IsotropicStrategy)\n\nPerforms Gaussian isotropic mutation of the recombinant x given the strategy s  by adding Gaussian noise as follows:\n\nx_i^prime = x_i + ssigma mathcalN_i(01)\n\n\n\n\n\n","category":"method"},{"location":"mutation/#Evolutionary.gaussian-Tuple{AbstractArray{T,1} where T,AnisotropicStrategy}","page":"Mutation","title":"Evolutionary.gaussian","text":"gaussian(x, s::AnisotropicStrategy)\n\nPerforms Gaussian anisotropic mutation of the recombinant x given the strategy s  by adding Gaussian noise as follows:\n\nx_i^prime = x_i + ssigma_i mathcalN_i(01)\n\n\n\n\n\n","category":"method"},{"location":"mutation/#Evolutionary.cauchy-Tuple{AbstractArray{T,1} where T,IsotropicStrategy}","page":"Mutation","title":"Evolutionary.cauchy","text":"cauchy(x, s::IsotropicStrategy)\n\nPerforms isotropic mutation of the recombinant x given the strategy s  by adding a noise from the Cauchy distribution as follows:\n\nx_i^prime = x_i + ssigma_i delta_i\n\nwhere delta is a Cauchy random variable with the scale parameter t = 1 [2].\n\n\n\n\n\n","category":"method"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"List of ES strategy mutation operations:","category":"page"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"gaussian(::IsotropicStrategy)\ngaussian(::AnisotropicStrategy)","category":"page"},{"location":"mutation/#Evolutionary.gaussian-Tuple{IsotropicStrategy}","page":"Mutation","title":"Evolutionary.gaussian","text":"gaussian(s::IsotropicStrategy)\n\nPerforms in-place mutation of the isotropic strategy s modifying its mutated strategy parameter sigma with Gaussian noise as follows:\n\nsigma^prime = sigma exp(tau_0 mathcalN(01))\n\n\n\n\n\n","category":"method"},{"location":"mutation/#Evolutionary.gaussian-Tuple{AnisotropicStrategy}","page":"Mutation","title":"Evolutionary.gaussian","text":"gaussian(s::AnisotropicStrategy)\n\nPerforms in-place mutation of the anisotropic strategy s modifying its mutated strategy parameter sigma with Gaussian noise as follows:\n\nsigma_i^prime = sigma_i exp(tau_0 mathcalN(01) + tau_i mathcalN(01))\n\n\n\n\n\n","category":"method"},{"location":"mutation/#Genetic-Algorithm-1","page":"Mutation","title":"Genetic Algorithm","text":"","category":"section"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"List of the binary mutation operations:","category":"page"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"flip\nbitinversion","category":"page"},{"location":"mutation/#Evolutionary.flip","page":"Mutation","title":"Evolutionary.flip","text":"flip(recombinant)\n\nReturns an in-place mutated binary recombinant with a bit flips at random positions.\n\n\n\n\n\n","category":"function"},{"location":"mutation/#Evolutionary.bitinversion","page":"Mutation","title":"Evolutionary.bitinversion","text":"bitinversion(recombinant)\n\nReturns an in-place mutated binary recombinant with its bits inverted.\n\n\n\n\n\n","category":"function"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"List of the real valued mutation operations:","category":"page"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"uniform(::Real)\ngaussian(::Real)\ndomainrange","category":"page"},{"location":"mutation/#Evolutionary.uniform-Tuple{Real}","page":"Mutation","title":"Evolutionary.uniform","text":"uniform(r = 1.0)\n\nReturns an in-place real valued mutation function that performs the uniform distributed mutation [1].\n\nThe mutation operator randomly chooses a number z in from the uniform distribution on the interval -rr, the mutation range. The mutated individual is given by\n\nx_i^prime = x_i + z_i\n\n\n\n\n\n","category":"method"},{"location":"mutation/#Evolutionary.gaussian-Tuple{Real}","page":"Mutation","title":"Evolutionary.gaussian","text":"gaussian(σ = 1.0)\n\nReturns an in-place real valued mutation function that performs the normal distributed mutation [1].\n\nThe mutation operator randomly chooses a number z in from the normal distribution mathcalN(0sigma) with standard deviation sigma. The mutated individual is given by\n\nx_i^prime = x_i + z_i\n\n\n\n\n\n","category":"method"},{"location":"mutation/#Evolutionary.domainrange","page":"Mutation","title":"Evolutionary.domainrange","text":"domainrange(valrange, m = 20)\n\nReturns an in-place real valued mutation function that performs the BGA mutation scheme with the mutation range valrange and the mutation probability 1/m [1].\n\n\n\n\n\n","category":"function"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"List of the combinatorial mutation operations (applicable to binary vectors):","category":"page"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"inversion\ninsertion\nswap2\nscramble\nshifting","category":"page"},{"location":"mutation/#Evolutionary.inversion","page":"Mutation","title":"Evolutionary.inversion","text":"inversion(recombinant)\n\nReturns an in-place mutated individual with a random arbitrary length segment of the genome in the reverse order.\n\n\n\n\n\n","category":"function"},{"location":"mutation/#Evolutionary.swap2","page":"Mutation","title":"Evolutionary.swap2","text":"swap2(recombinant)\n\nReturns an in-place mutated individual with a two random elements of the genome are swapped.\n\n\n\n\n\n","category":"function"},{"location":"mutation/#Evolutionary.scramble","page":"Mutation","title":"Evolutionary.scramble","text":"scramble(recombinant)\n\nReturns an in-place mutated individual with elements, on a random arbitrary length segment of the genome, been scrambled.\n\n\n\n\n\n","category":"function"},{"location":"mutation/#Evolutionary.shifting","page":"Mutation","title":"Evolutionary.shifting","text":"shifting(recombinant)\n\nReturns an in-place mutated individual with a random arbitrary length segment of the genome been shifted to an arbitrary position.\n\n\n\n\n\n","category":"function"},{"location":"mutation/#References-1","page":"Mutation","title":"References","text":"","category":"section"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"[1]: Mühlenbein, H. and Schlierkamp-Voosen, D.: Predictive Models for the Breeder Genetic Algorithm: I. Continuous Parameter Optimization. Evolutionary Computation, 1 (1), pp. 25-49, 1993.","category":"page"},{"location":"mutation/#","page":"Mutation","title":"Mutation","text":"[2]: Yao, Xin, and Yong Liu. \"Fast evolution strategies.\" In International Conference on Evolutionary Programming, pp. 149-161. Springer, Berlin, Heidelberg, 1997.","category":"page"},{"location":"crossover/#Crossover-1","page":"Crossover","title":"Crossover","text":"","category":"section"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"In genetic algorithms and evolutionary computation, crossover, also called recombination, is a genetic operator used to combine the genetic information of two parents to generate new offspring.","category":"page"},{"location":"crossover/#Recombination-Interface-1","page":"Crossover","title":"Recombination Interface","text":"","category":"section"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"All recombination operations have following call interface: recombination(i1, i2) where i1 and i2 are the same type individuals that involved in recombination to produce an offspring. The recombination function returns pair of recombined individuals.","category":"page"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"Note: Some of the selection algorithms implemented as function closures, in order to provide additional parameters for the specified above recombination interface.","category":"page"},{"location":"crossover/#Operations-1","page":"Crossover","title":"Operations","text":"","category":"section"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"List of the ES strategy recombination operations:","category":"page"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"average(::Vector{<:AbstractStrategy})","category":"page"},{"location":"crossover/#Evolutionary.average-Tuple{Array{#s3,1} where #s3<:AbstractStrategy}","page":"Crossover","title":"Evolutionary.average","text":"average(ss::Vector{<:AbstractStrategy})\n\nReturns the average value of the mutation parameter sigma of strategies ss.\n\n\n\n\n\n","category":"method"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"List of the ES population recombination operations:","category":"page"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"average(population::Vector{T}) where {T <: AbstractVector}\nmarriage","category":"page"},{"location":"crossover/#Evolutionary.average-Union{Tuple{Array{T,1}}, Tuple{T}} where T<:(AbstractArray{T,1} where T)","page":"Crossover","title":"Evolutionary.average","text":"average(population)\n\nReturns an one offspring individual of a multi-parent recombination by averaging population.\n\n\n\n\n\n","category":"method"},{"location":"crossover/#Evolutionary.marriage","page":"Crossover","title":"Evolutionary.marriage","text":"marriage(population)\n\nReturns an one offspring individual of a multi-parent recombination by random copying from population.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"Binary crossovers:","category":"page"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"singlepoint\ntwopoint\nuniform","category":"page"},{"location":"crossover/#Evolutionary.singlepoint","page":"Crossover","title":"Evolutionary.singlepoint","text":"singlepoint(v1, v2)\n\nSingle point crossover between v1 and v2 individuals.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.twopoint","page":"Crossover","title":"Evolutionary.twopoint","text":"twopoint(v1, v2)\n\nTwo point crossover between v1 and v2 individuals.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.uniform","page":"Crossover","title":"Evolutionary.uniform","text":"uniform(v1, v2)\n\nUniform crossover between v1 and v2 individuals.\n\n\n\n\n\nuniform(r = 1.0)\n\nReturns an in-place real valued mutation function that performs the uniform distributed mutation [1].\n\nThe mutation operator randomly chooses a number z in from the uniform distribution on the interval -rr, the mutation range. The mutated individual is given by\n\nx_i^prime = x_i + z_i\n\n\n\n\n\n","category":"function"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"Real valued crossovers:","category":"page"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"identity\ndiscrete\nwaverage\nintermediate\nline","category":"page"},{"location":"crossover/#Base.identity","page":"Crossover","title":"Base.identity","text":"identity(v1, v2)\n\nReturns the same parameter individuals v1 and v2 as an offspring pair.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.discrete","page":"Crossover","title":"Evolutionary.discrete","text":"Discrete recombination\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.waverage","page":"Crossover","title":"Evolutionary.waverage","text":"Weighted arithmetic mean recombination\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.intermediate","page":"Crossover","title":"Evolutionary.intermediate","text":"intermediate(d::Real=0.0)\n\nReturns an extended intermediate recombination operation, see Recombination Interface, which generates offspring u and v as\n\nu_i = x_i + alpha_i (y_i - x_i)\nv_i = y_i + alpha_i (x_i - y_i)\n\nwhere alpha_i is chosen uniform randomly in the interval -dd+1.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.line","page":"Crossover","title":"Evolutionary.line","text":"line(d::Real=0.0)\n\nReturns a extended line recombination operation, see Recombination Interface, which generates offspring u and v as\n\nu_i = x_i + alpha (y_i - x_i)\nv_i = y_i + alpha (x_i - y_i)\n\nwhere alpha is chosen uniform randomly in the interval -dd+1.\n\n\n\n\n\n","category":"function"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"Permutation crossovers:","category":"page"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"pmx\nox1\ncx\nox2\npos","category":"page"},{"location":"crossover/#Evolutionary.pmx","page":"Crossover","title":"Evolutionary.pmx","text":"Partially mapped crossover\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.ox1","page":"Crossover","title":"Evolutionary.ox1","text":"Order crossover\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.cx","page":"Crossover","title":"Evolutionary.cx","text":"Cycle crossover\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.ox2","page":"Crossover","title":"Evolutionary.ox2","text":"Order-based crossover\n\n\n\n\n\n","category":"function"},{"location":"crossover/#Evolutionary.pos","page":"Crossover","title":"Evolutionary.pos","text":"Position-based crossover\n\n\n\n\n\n","category":"function"},{"location":"crossover/#References-1","page":"Crossover","title":"References","text":"","category":"section"},{"location":"crossover/#","page":"Crossover","title":"Crossover","text":"[1]: Mühlenbein, H. and Schlierkamp-Voosen, D.: Predictive Models for the Breeder Genetic Algorithm: I. Continuous Parameter Optimization. Evolutionary Computation, 1 (1), pp. 25-49, 1993.","category":"page"},{"location":"ga/#Genetic-Algorithm-1","page":"Genetic Algorithm","title":"Genetic Algorithm","text":"","category":"section"},{"location":"ga/#","page":"Genetic Algorithm","title":"Genetic Algorithm","text":"GA","category":"page"},{"location":"ga/#Evolutionary.GA","page":"Genetic Algorithm","title":"Evolutionary.GA","text":"Implementation of Genetic Algorithm\n\nThe constructor takes following keyword arguments:\n\npopulationSize: Size of the population\ncrossoverRate: The fraction of the population at the next generation, not including elite children, that is created by the crossover function.\nmutationRate: Probability of chromosome to be mutated\nɛ: Positive integer specifies how many individuals in the current generation are guaranteed to survive to the next generation. Floating number specifies fraction of population.\nselection: Selection function\ncrossover: Crossover function (default: identity)\nmutation: Mutation function (default: identity)\n\n\n\n\n\n","category":"type"},{"location":"ga/#Description-1","page":"Genetic Algorithm","title":"Description","text":"","category":"section"},{"location":"ga/#","page":"Genetic Algorithm","title":"Genetic Algorithm","text":"The Genetic Algorithm  is a metaheuristic inspired by the process of natural selection that belongs to the larger class of evolutionary algorithms (EA). Genetic algorithms are commonly used to generate high-quality solutions to optimization and search problems by relying on biologically inspired operators such as Mutation, Crossover and Selection [1].","category":"page"},{"location":"ga/#References-1","page":"Genetic Algorithm","title":"References","text":"","category":"section"},{"location":"ga/#","page":"Genetic Algorithm","title":"Genetic Algorithm","text":"[1]: http://www.scholarpedia.org/article/Genetic_algorithms","category":"page"},{"location":"#Evolutionary.jl-1","page":"Home","title":"Evolutionary.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The package Evolutionary aims to provide a library for evolutionary optimization. It provides implementation of (murho  stackrel+ lambda)-Evolution Strategy, (mumu_I lambda)-Covariance Matrix Adaptation Evolution Strategy and Genetic Algorithm, as well as a rich set of mutation, recombination, crossover and selection functions.","category":"page"},{"location":"#Getting-started-1","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install the package just type","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add Evolutionary","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A simple example of using the GA algorithm to find minium of the Sphere function.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Evolutionary\nresult = Evolutionary.optimize(\n      x -> sum(x.^2), ones(3),\n      GA(populationSize = 100, selection = susinv,\n         crossover = discrete, mutation = domainrange(ones(3))))","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"CurrentModule = Evolutionary","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Evolutionary","category":"page"},{"location":"tutorial/#Optimization-1","page":"Tutorial","title":"Optimization","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To show how the Evolutionary package can be used, we minimize the Rosenbrock function, a classical test problem for numerical optimization. We'll assume that you've already installed the Evolutionary package using Julia's package manager.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, we load Evolutionary and define the Rosenbrock function:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Evolutionary\nf(x) = (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Once we've defined this function, we can find the minimizer (the input that minimizes the objective) and the minimum (the value of the objective at the minimizer) using any of our favorite optimization algorithms. With a function defined, we just specify a form of an individual x of the population for an evolutionary algorithm, and call optimize with a starting individual x0 and a particular optimization algorithm, e.g. CMAES():","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"x0 = [0.0, 0.0];\nEvolutionary.optimize(f, x0, CMAES())","category":"page"},{"location":"tutorial/#Configurable-options-1","page":"Tutorial","title":"Configurable options","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"There are several options that simply take on some default values if the user doesn't provide any.","category":"page"},{"location":"tutorial/#Algorithm-options-1","page":"Tutorial","title":"Algorithm options","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"There are different algorithms available in Evolutionary, and they are all listed below. Notice that the constructors are written without input here, but they generally take keywords to tweak the way they work. See the pages describing each solver for more detail.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"GA()\nES()\nCMAES()","category":"page"},{"location":"tutorial/#General-options-1","page":"Tutorial","title":"General options","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In addition to the algorithm, you can alter the behavior of the optimization procedure by using the following Options keyword arguments:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Options","category":"page"},{"location":"tutorial/#Evolutionary.Options","page":"Tutorial","title":"Evolutionary.Options","text":"Configurable options with defaults:\n\nabstol::Float64 = 1e-32\nreltol::Float64 = 1e-32\nsuccessive_f_tol::Integer = 10\niterations::Integer = 1000\nstore_trace::Bool = false\nshow_trace::Bool  = false\nshow_every::Integer = 1\ncallback::TCallback = nothing\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We currently recommend the statically dispatched interface by using the Evolutionary.Options constructor:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"res = Evolutionary.optimize(x->-sum(x),\n                            BitVector(zeros(3)),\n                            GA(),\n                            Evolutionary.Options(iterations=10))","category":"page"},{"location":"tutorial/#Obtaining-results-1","page":"Tutorial","title":"Obtaining results","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"After we have our results in res object, we can use the API for getting optimization results. This consists of a collection of functions. They are not exported, so they have to be prefixed by Evolutionary.. Say we do the following optimization:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"res = Evolutionary.optimize(x->-sum(x), BitVector(zeros(3)), GA())","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"You can inspect the result by using a collection of the auxiliary functions, e.g. the minimizer and minimum of the objective functions, which can be found using","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Evolutionary.minimizer(res)\nEvolutionary.minimum(res)","category":"page"},{"location":"tutorial/#Complete-list-of-functions-1","page":"Tutorial","title":"Complete list of functions","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"An OptimizationResults interface for representing an optimization result.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"OptimizationResults\nsummary(::OptimizationResults)\nminimizer(::OptimizationResults)\nminimum(::OptimizationResults)\niterations(::OptimizationResults)\niteration_limit_reached(::OptimizationResults)\ntrace(::OptimizationResults)\nf_calls(::OptimizationResults)\ntol(::OptimizationResults)","category":"page"},{"location":"tutorial/#Evolutionary.OptimizationResults","page":"Tutorial","title":"Evolutionary.OptimizationResults","text":"Abstract evolutionary optimization result type\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Base.summary-Tuple{Evolutionary.OptimizationResults}","page":"Tutorial","title":"Base.summary","text":"summary(result)\n\nShows the optimization algorithm that produced this result.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Evolutionary.minimizer-Tuple{Evolutionary.OptimizationResults}","page":"Tutorial","title":"Evolutionary.minimizer","text":"minimizer(result)\n\nA minimizer object from the optimization result.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Base.minimum-Tuple{Evolutionary.OptimizationResults}","page":"Tutorial","title":"Base.minimum","text":"minimum(result)\n\nA minimum value from the optimization result.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Evolutionary.iterations-Tuple{Evolutionary.OptimizationResults}","page":"Tutorial","title":"Evolutionary.iterations","text":"iterations(result)\n\nA number of iterations to reach the minimum.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Evolutionary.iteration_limit_reached-Tuple{Evolutionary.OptimizationResults}","page":"Tutorial","title":"Evolutionary.iteration_limit_reached","text":"iteration_limit_reached(result)\n\nReturns true if the iteration limit was reached.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Evolutionary.trace-Tuple{Evolutionary.OptimizationResults}","page":"Tutorial","title":"Evolutionary.trace","text":"trace(result)\n\nReturns a trace of optimization states from the optimization result.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#NLSolversBase.f_calls-Tuple{Evolutionary.OptimizationResults}","page":"Tutorial","title":"NLSolversBase.f_calls","text":"f_calls(result)\n\nReturns a number of an objective function calls.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Evolutionary.tol-Tuple{Evolutionary.OptimizationResults}","page":"Tutorial","title":"Evolutionary.tol","text":"tol(result)\n\nReturns an absolute tollerance value of the optimization result.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"An implementation of the result object for evolutionary optimizations.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"EvolutionaryOptimizationResults\nconverged(::EvolutionaryOptimizationResults)\ntol(::EvolutionaryOptimizationResults)","category":"page"},{"location":"tutorial/#Evolutionary.EvolutionaryOptimizationResults","page":"Tutorial","title":"Evolutionary.EvolutionaryOptimizationResults","text":"Evolutionary optimization result type\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Evolutionary.converged-Tuple{Evolutionary.EvolutionaryOptimizationResults}","page":"Tutorial","title":"Evolutionary.converged","text":"converged(result)\n\nReturns true if the optimization sucesfully coverged to a minimum value.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Evolutionary.tol-Tuple{Evolutionary.EvolutionaryOptimizationResults}","page":"Tutorial","title":"Evolutionary.tol","text":"tol(result)\n\nReturns an absolute tollerance value of the optimization result.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Trace-1","page":"Tutorial","title":"Trace","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"When store_trace and/or show_trace options are set to true in the Option(@ref) object, an optimization trace is either captured and/or shown on the screen. By default, only the current state minimum value is displayed in the trace. In order to extend trace record, you need to override trace! function providing specialize function behavior on one of specific parameters.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"trace!(::Dict{String,Any}, Any, Any, Any, Any, Any)","category":"page"},{"location":"tutorial/#Evolutionary.trace!-Tuple{Dict{String,Any},Any,Any,Any,Any,Any}","page":"Tutorial","title":"Evolutionary.trace!","text":"trace!(record::Dict{String,Any}, objfun, state, population, method, options)\n\nUpdate the trace record. This function allows to supplement an additional information into the optimization algorithm trace by modifing a trace record. It can be overwiden by specifing particular parameter types.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Commonly, you would define a specializations of a state, population, or method parameters of trace! function, e.g.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function trace!(record::Dict{String,Any}, objfun, state, population, method::CMAES, options)\n    record[\"σ\"] = state.σ\nend","category":"page"}]
}
